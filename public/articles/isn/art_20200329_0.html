<h1>Procédure d'interruption<span class="date">29/03/2020</span></h1>

<p>
  Une demande d'interruption de l'extérieur (par une horloge par exemple) se fait normalement via un pin
  du processeur, lorsque l'instruction en cours a terminé son exécution et si le processeur n'est pas déjà interrompu,
  l'adresse de saut de l'interruption est récupérée.
  Pour permettre un retour à l'état d'avant l'interruption on utilise le stack pour stocker tous les registres.
  Le flag interruption est alors mis et le processeur saute à la bonne adresse.
  Sur le schéma de l'architecture le bus qui permet de relier le registre JH à l'entrée de la mémoire
  n'est pas représenté explicitement.
</p>

<p>
  Dans l'émulateur le pin est représenté par une fonction qui permet de faire une demande d'instruction
  en donnant une adresse qui est stockée dans un buffer en attendant la fin de l'instruction en cours.
</p>

<p>
  Seulement en pratique je me suis rendu compte qu'il était impossible de programmer une routine d'interruption
  qui arrive à recharger tous les registres avec les bonnes valeurs.
  Il m'aurait fallu une instruction spécifique pour cela mais comme mon set d'instruction est plein je vais tricher;
  si le processeur détecte que le flag interruption passe de 1 à 0 il comprendra ça comme un retour d'interruption.
  Pour sortir d'une interruption il suffira donc de charger le registre des flags avec sa valeur stockée dans le stack,
  le microcode du processeur se chargera du reste.
</p>

<p>
  Pour demander une interruption depuis le programme il faudra faire de même en faisant passer le bit interruption de 0 à 1,
  l'adresse de saut sera celle composée par le registre JH et l'accumulateur.
</p>

<p>
  Ça faisait 5 jours que je cherchais cette solution, c'est soulageant de savoir que je n'ai pas à abandonner
  le support des interruptions car c'est un principe intéressant à utiliser.
</p>

<p>Stackframe d'interruption :</p>
<img src="/img/intStackframe.svg" class="center four-fifths" alt="stack frame">
