<h1>Architecture machine</h1>

<h2>Présentation</h2>

	<p>
		Comme il existe de nombreux concepts de machines à vapeur, de réacteurs nucléaires ou encore de moteurs fusée,
		il y a plein de manières de concevoir le mode opératoire d'un ordinateur.
		Les premiers ordinateurs utilisaient une architecture "de Harvard" où le programme est séparé des données et
		ne peut pas être modifié par la machine.
		Ce système rend certaines choses assez simples puisque le programme peut par exemple être stocké sur
		une bande de papier perforée à la manière d'une boîte à musique.
	</p>

	<img class="half center" src="/img/harvard.svg">

	<p>
		Les ordinateurs modernes utilise des architectures de typee "Von Neumann", les données et le programme sont mélangés,
		cela donne plus de libertés : il alors par exemple possible sur un même ordinateur d'écrire un programme puis de l'exécuter sans
		avoir à extraire physiquement le programme de la mémoire des données pour l'insérer dans la mémoire programme.
	</p>

	<img class="half center" src="/img/neumann.svg">

	<p>
		Il va maintenant falloir se demander à quoi ressemble l'intérieur du bloc "CPU".
		L'unité de contrôle est responsable du décodage et de l'exécution des instructions en donnant des ordres au reste du système
		alors que la partie arithmétique et logique	se charge de transformer les données (addition de deux nombres par exemple).
		L'architecture machine s'intéresse surtout à la manière dont ces composants communiquent et coopèrent.
	</p>

	<p>
		On appellera "bus" les composants qui transportent les données à l'intérieur du processeur,
		en pratique il s'agit d'un paquet de fils parallèles (un fil par bit de donnée).
		Les registres sont quand à eux sont des composants qui permettent le stockage temporaire d'une valeur,
		par exemple le compteur programme est un registre qui	contient l'adresse mémoire de l'instruction à exécuter.
	</p>


<h2>Exemple</h2>
	<p>
		Voici une architecture purement fictive, regardons comment circuleraient les données dans le processeur :
	</p>
	<img class="half center" src="/img/testarch1.svg">

	<p>
		Avec :
		<ul>
			<li>UAL l'unité arithmétique et logique</li>
			<li>PC le compteur programme</li>
			<li>ADR le registre d'adresse mémoire</li>
			<li>IR le registre d'instruction</li>
			<li>DECO le décodeur d'instruction / la logique de contrôle</li>
			<li>FL le registre des "flags" (informations sur le résultat de l'UAL)</li>
			<li>A et B les registres généraux</li>
		</ul>
	</p>

	<p>
		Effectuons l'opération "Z := X + Y" avec X,Y,Z des valeurs dans la mémoire dont les adresses sont explicités avec l'instruction. <br>

		<ul>
		<li>Cycle 1 trouver l'instruction :
		<ol>
			<li>On envoie l'adresse de PC à la mémoire, on récupère la donnée, on la stocke dans IR</li>
			<li>Pendant ce temps là, on incrémente le compteur programme</li>
			<li>On décode l'instruction : il faut prendre deux nombres dans la mémoire, faire une addition, mettre le résultat dans la mémoire </li>
		</ol></li>
		<br>
		<li>Cycle 2 trouver X :
		<ol>
			<li>On envoie l'adresse de PC à la mémoire, on récupère la donnée, on la stocke dans ADR, on a trouvé l'adresse de X !</li>
			<li>Pendant ce temps là, on incrémente le compteur programme</li>
			<li>On envoie l'adresse de ADR à la mémoire, on récupère la donnée, on la stocke dans A, on a trouvé X !</li>
		</ol></li>
		<br>
		<li>Cycle 3 trouver Y :
		<ol>
			<li>On envoie l'adresse de PC à la mémoire, on récupère la donnée, on la stocke dans ADR, on a trouvé l'adresse de Y !</li>
			<li>Pendant ce temps là, on incrémente le compteur programme</li>
			<li>On envoie l'adresse de ADR à la mémoire, on récupère la donnée, on la stocke dans B, on a trouvé Y !</li>
		</ol></li>
		<br>
		<li>Cycle 4 renvoyer Z :
		<ol>
			<li>On envoie l'adresse de PC à la mémoire, on récupère la donnée, on la stocke dans ADR, on a trouvé l'adresse de Z !</li>
			<li>Pendant ce temps là, on incrémente le compteur programme</li>
			<li>On demande à l'UAL d'effectuer l'opération "A+B" et on envoie le résultat à la mémoire, on a trouvé Z !</li>
		</ol></li>

		</ul>
	</p>

<h2>Autre exemple et comparaison</h2>
	<p>
		Voici un autre exemple d'architecture un peu plus élaborée :
	</p>
	<img class="half center" src="/img/testarch2.svg">
	<p>
		Avec SP le "stack pointeur", le registre qui garde l'adresse de la pile et NULL le registre vide.
	</p>


<h2>Le dilemne de l'octet</h2>
	<p>
		La quasi totalité des processeurs modernes fonctionnent sur base du système de l'octet : 8, 16, 32, 64bits.
		La mémoire des ordinateurs modernes est indexées à l'octet près pour des raisons historiques et pratique
		(initialement pour l'encodage des caractères, norme ASCII). Les machines plus primitives utilisaient un nombre
		assez grand de bits puisque le but était plutôt d'avoir le plus de chiffres significatifs pour du calcul scientifique,
		et non à des fins de traitement de texte.

		L'idée n'étant pas de construire un système compatible avec les mémoires actuelles, on choisira le nombre de
		bits avant tout pour coincider avec l'architecture choisie.
	</p>
