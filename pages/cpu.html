
<!DOCTYPE html>

<html prefix="og: https://ogp.me/ns#">

    <head>
      <meta charset="utf-8">
      <link rel="stylesheet" href="/style/style.css" />
      <link rel="stylesheet" href="/style/feed.css" />
      <link rel="icon" href="/img/icon.jpg" />
      <title>TIPE Machines</title>

      <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        img-src 'self' *;
        media-src 'self' *;
        object-src 'self' *;
        script-src 'self' 'unsafe-inline';
        style-src 'self' 'unsafe-inline';
        frame-src 'self' *;
        "
      >

      <meta property="og:title" content="Scouarn">
      <meta property="og:image" content="/img/thumbnail.jpg">
      <meta property="og:description" content="Code et bidouille.">

    </head>

    <body>

        <header>
          <link rel="stylesheet" href="/style/banner.css" />
          <a href="/">
            <div id="banner">
                <img src="/img/console.png" alt="banner"/>
                <img src="/img/banner.png" alt="banner"/>
                <img src="/img/scouarn_sg.png" alt="banner"/>
            </div>
          </a>
        </header>

    <section id="main_content">

    

    <aside id="menu">
    <link rel="stylesheet" href="/style/menu.css" />
    <div class="box">
    <h1>Navigation</h1>
    <ul>

<a href="/pages/main.html"><li cat="main">Acceuil</li></a>
<a href="/pages/physique.html"><li cat="physique">Physique</li></a>
<a href="/pages/maths.html"><li cat="maths">Maths</li></a>
<a href="/pages/astro.html"><li cat="astro">Astronomie</li></a>
<a href="/pages/micro.html"><li cat="micro">Microscopie</li></a>
<a href="/pages/jeux.html"><li cat="jeux">Jeux</li></a>
<a href="/pages/cpu.html"><li cat="cpu">TIPE Machines</li></a>
<a href="/pages/dessin.html"><li cat="dessin">BD Shadoks</li></a>


    </ul>
    </div>
    </aside>


    
    <section id="article_feed">
        <article class='box'><h1>Présentation du TIPE</h1>

<h2>Avant propos</h2>
	<p>
		Le but de cette page est avant tout de présenter certains points importants.
		Le sujet peut paraître hors de portée puisque se trouvant entre l'informatique et l'électronique.
		Ici sont compilées quelques ressources et exemples abordables pour ne pas se retrouver complètement perdu au milieu d'une fiche technique de processeur.
		Les diagrammes non sourcés ont été réalisés par moi.
	</p>

	<p>
		Les Shadoks et comment compter avec seulement 4 chiffres :
	</p>
				<iframe class="center" width="560" height="315" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
					src="https://www.youtube-nocookie.com/embed/lP9PaDs2xgQ">
				</iframe>

  <p>
		Les Matics, indroduction à l'informatique (25 vidéos de 3min) :
	</p>

			<iframe class="center" width="560" height="315" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
				src="https://www.youtube-nocookie.com/embed/playlist?list=PLjS13O8ZcTgYsOCS9D2eWVikCfJUD5kBe">
			</iframe>



<h2>Motivations</h2>
	<p>
		(ou prétextes pour m'écarter du sujet) <br>
		Nouvelles architectures : TIS-100, multiprocesseurs, etc...<br>
		Construction des circuits électroniques. <br>
		Fascination pour l'informatique et pour l'électronique. <br>
		[...]
	</p>

<h2>Plan de route</h2>
	<p>
		<ul>
			<li>Cahier des charges</li>
			<li>Conception</li>
			<li>Modélisation en code et assembleur</li>
			<li>Prototype d'additionneur électronique</li>
			<li>Construction du processeur</li>
			<li>Programmation</li>
			<li>Démonstration</li>
		</ul>
	</p>
</article><article class='box'><h1>Cadre historique</h1>

<h2>Calcul mécanique</h2>
	<p>
		Le mot calcul vient du mot latin pour "caillou". En effet dans le temps quand on n'avait plus assez de doigts
		pour compter, il était convenable d'utiliser des petites pierres pour représenter des quantités.
		De nombreux systèmes ont été conçu : mécanismes d'horlogerie, règles coulissantes, etc...
	</p>

	<p>
		<ul>
			<li>
				Bouliers :
						<a href="https://fr.wikipedia.org/wiki/Abaque_(calcul)">https://fr.wikipedia.org/wiki/Abaque_(calcul)</a>
			</li>

			<li>
				Machine d'Anticythère :
					<a href="https://fr.wikipedia.org/wiki/Machine_d%27Anticyth%C3%A8re">https://fr.wikipedia.org/wiki/Machine_d%27Anticyth%C3%A8re</a>
			</li>

			<li>
				Machines de Babbage :
					<a href="https://fr.wikipedia.org/wiki/Charles_Babbage">https://fr.wikipedia.org/wiki/Charles_Babbage</a>
			</li>

			<li>
				Mickaël Launay présente différentes machines à calculer dans une série de vidéos :
				<iframe class="center" width="560" height="315" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
					src="https://www.youtube-nocookie.com/embed/GnMgHsos7cY">
				</iframe>
			</li>
		</ul>

  </p>

<h2>Calcul électromécanique</h2>
	<p>
		Le relai électromécanique servait initialement à amplifier le signal des lignes de télégraphe,
		mais il peut aussi servir dans des circuits plus élaborés, pour automatiser les connexions téléphoniques par exemple.
	</p>
	<p>
		<ul>
			<li>
				Machines de Zuse :
					<a href="https://en.wikipedia.org/wiki/Konrad_Zuse">https://en.wikipedia.org/wiki/Konrad_Zuse</a>
			</li>

			<li>
				Bombe de Turing :
					<a href="https://en.wikipedia.org/wiki/Bombe">https://en.wikipedia.org/wiki/Bombe</a>
			</li>

			<li>
				FACOM−128 : <br>
					<iframe class="center" width="560" height="315" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
						src="https://www.youtube-nocookie.com/embed/_j544ELauus">
					</iframe>
			</li>

			<li>
				Exemple récent : ordinateur d'Harry Porter : <br>
					<iframe class="center" width="560" height="315" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
						src="https://www.youtube-nocookie.com/embed/tsp2JntuZ3c">
					</iframe>
			</li>
		</ul>

	</p>






<h2>Premières machines électroniques</h2>
	<p>
		En raison de leur délai d'activation qui impactait la durée des calculs, les relais électromécaniques
		ont été ramplacées par des lampes cathodiques.
	</p>

	<p>
		<ul>
			<li>
				Colossus, tout premier ordinateur entièrement électronique :
				<iframe class="center" width="560" height="315" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
					src="https://www.youtube.com/embed/9HH-asvLAj4">
				</iframe>
			</li>

			<li>
				ENIAC :
					<a href="https://en.wikipedia.org/wiki/ENIAC">https://en.wikipedia.org/wiki/ENIAC</a>
			</li>

			<li>
				EDSAC :
					<a href="https://en.wikipedia.org/wiki/EDSAC">https://en.wikipedia.org/wiki/EDSAC</a>
			</li>
		</ul>




<h2>Révolution du transistor</h2>
	<p>
		L'invention du transistor a permi de grands progrès : taille, consommation, puis par le programme spatial américain.
	</p>

	<p>
		<ul>
			<li>
				Intel 4004, le premier processeur à tenir sur une seule puce :
					<a href="https://en.wikipedia.org/wiki/Intel_4004">https://en.wikipedia.org/wiki/Intel_4004</a>
			</li>
			<li>
				MOS 6502, a lancé le concepte de l'ordinateur personnel :
					<a href="https://en.wikipedia.org/wiki/MOS_Technology_6502">https://en.wikipedia.org/wiki/MOS_Technology_6502</a>
			</li>
			<li>
				Intel 8086, a défini l'architecture de la grande majorité des PC :
					<a href="https://en.wikipedia.org/wiki/Intel_8086">https://en.wikipedia.org/wiki/Intel_8086</a>
			</li>
			<li>
				Le processeur ARM, utilisé dans les téléphones portables pour sa faible consommation électrique :
					<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
			</li>

			<li>
				Le "Mégaprocesseur" construit à partir de transistors discrets pour être exposé :
				<iframe class="center" width="560" height="315" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
					src="https://www.youtube.com/embed/EMO3dZAizb4">
				</iframe>
			</li>
		</ul>
	</p>

<h2>Ordinateurs quantiques</h2>
	<p>
		Plutôt hors propos. Simulation possible mais je ne m'y connais pas beaucoup : à étudier !
  </p>
</article><article class='box'><h1>Logique combinatoire et électronique</h1>

<h2>Présentation</h2>
  <p>

  </p>

<h2>Implémentations et technologies</h2>
  <p>

  </p>

  [EXEMPLE : MÉCANIQUE] <br>
  [EXEMPLE : RELAI] <br>
  [EXEMPLE : TRANSISTOR ET DIFFÉRENTS TRANSISTORS] <br>
  [EXEMPLE : MINECRAFT] <br>


<h2>Additionneur binaire</h2>
  <p>

  </p>

<h2>Décodeur binaire</h2>
  <p>

  </p>

<h2>Mémoire</h2>
  <p>

  </p>
</article><article class='box'><h1>Architecture machine</h1>

<h2>Présentation</h2>

	<p>
		Comme il existe de nombreux concepts de machines à vapeur, de réacteurs nucléaires ou encore de moteurs fusée,
		il y a plein de manières de concevoir le mode opératoire d'un ordinateur.
		Les premiers ordinateurs utilisaient une architecture "de Harvard" où le programme est séparé des données et
		ne peut pas être modifié par la machine.
		Ce système rend certaines choses assez simples puisque le programme peut par exemple être stocké sur
		une bande de papier perforée à la manière d'une boîte à musique.
	</p>

	<img class="half center" src="/img/harvard.svg">

	<p>
		Les ordinateurs modernes utilise des architectures de typee "Von Neumann", les données et le programme sont mélangés,
		cela donne plus de libertés : il alors par exemple possible sur un même ordinateur d'écrire un programme puis de l'exécuter sans
		avoir à extraire physiquement le programme de la mémoire des données pour l'insérer dans la mémoire programme.
	</p>

	<img class="half center" src="/img/neumann.svg">

	<p>
		Il va maintenant falloir se demander à quoi ressemble l'intérieur du bloc "CPU".
		L'unité de contrôle est responsable du décodage et de l'exécution des instructions en donnant des ordres au reste du système
		alors que la partie arithmétique et logique	se charge de transformer les données (addition de deux nombres par exemple).
		L'architecture machine s'intéresse surtout à la manière dont ces composants communiquent et coopèrent.
	</p>

	<p>
		On appellera "bus" les composants qui transportent les données à l'intérieur du processeur,
		en pratique il s'agit d'un paquet de fils parallèles (un fil par bit de donnée).
		Les registres sont quand à eux sont des composants qui permettent le stockage temporaire d'une valeur,
		par exemple le compteur programme est un registre qui	contient l'adresse mémoire de l'instruction à exécuter.
	</p>


<h2>Exemple</h2>
	<p>
		Voici une architecture purement fictive, regardons comment circuleraient les données dans le processeur :
	</p>
	<img class="half center" src="/img/testarch1.svg">

	<p>
		Avec :
		<ul>
			<li>UAL l'unité arithmétique et logique</li>
			<li>PC le compteur programme</li>
			<li>ADR le registre d'adresse mémoire</li>
			<li>IR le registre d'instruction</li>
			<li>DECO le décodeur d'instruction / la logique de contrôle</li>
			<li>FL le registre des "flags" (informations sur le résultat de l'UAL)</li>
			<li>A et B les registres généraux</li>
		</ul>
	</p>

	<p>
		Effectuons l'opération "Z := X + Y" avec X,Y,Z des valeurs dans la mémoire dont les adresses sont explicités avec l'instruction. <br>

		<ul>
		<li>Cycle 1 trouver l'instruction :
		<ol>
			<li>On envoie l'adresse de PC à la mémoire, on récupère la donnée, on la stocke dans IR</li>
			<li>Pendant ce temps là, on incrémente le compteur programme</li>
			<li>On décode l'instruction : il faut prendre deux nombres dans la mémoire, faire une addition, mettre le résultat dans la mémoire </li>
		</ol></li>
		<br>
		<li>Cycle 2 trouver X :
		<ol>
			<li>On envoie l'adresse de PC à la mémoire, on récupère la donnée, on la stocke dans ADR, on a trouvé l'adresse de X !</li>
			<li>Pendant ce temps là, on incrémente le compteur programme</li>
			<li>On envoie l'adresse de ADR à la mémoire, on récupère la donnée, on la stocke dans A, on a trouvé X !</li>
		</ol></li>
		<br>
		<li>Cycle 3 trouver Y :
		<ol>
			<li>On envoie l'adresse de PC à la mémoire, on récupère la donnée, on la stocke dans ADR, on a trouvé l'adresse de Y !</li>
			<li>Pendant ce temps là, on incrémente le compteur programme</li>
			<li>On envoie l'adresse de ADR à la mémoire, on récupère la donnée, on la stocke dans B, on a trouvé Y !</li>
		</ol></li>
		<br>
		<li>Cycle 4 renvoyer Z :
		<ol>
			<li>On envoie l'adresse de PC à la mémoire, on récupère la donnée, on la stocke dans ADR, on a trouvé l'adresse de Z !</li>
			<li>Pendant ce temps là, on incrémente le compteur programme</li>
			<li>On demande à l'UAL d'effectuer l'opération "A+B" et on envoie le résultat à la mémoire, on a trouvé Z !</li>
		</ol></li>

		</ul>
	</p>

<h2>Autre exemple et comparaison</h2>
	<p>
		Voici un autre exemple d'architecture un peu plus élaborée :
	</p>
	<img class="half center" src="/img/testarch2.svg">
	<p>
		Avec NULL le registre vide et MEM le registre d'interface mémoire.
	</p>

	<p>
		Ici, tous les registres sont reliés à l'UAL : dans un instruction on pourra choisir deux registres pour les termes de l'opération et un troisième pour le résultat.
		De plus ici on peut utiliser l'UAL pour incrémenter le compteur programme alors que dans l'exemple précédent un circuit dédié aurait été nécessaire.
		Il est par exemple aussi possible d'effectuer directement une addition avec un registre au lieu d'incrémenter si l'on veut effectuer un saut relatif.
		On peut choisir le registre vide si l'on ne veut pas stocker le résultat, ou bien si on veut faire des opérations qui n'utilisent qu'un seul terme.
		La mémoire est traitée comme un registre pour simplifier sont accès, l'adresse est toujours contrôlée par ADR.
		On a en bonus un troisième registre général (C) qui peut s'avérer pratique dans certains cas.
	</p>

	<p>
		Cette architecture est plus "puissante" et la logique de contrôle devrait être plus simple à mettre au point si l'on fait en sorte que les instructions
		soient de la forme "registre_0 := registre_1 {fonction} registre_2".
		Cela n'est pas vraiment faisable avec la première architecture et pas forcément la meilleure façon de tirer le maximum de cette dernière.
	</p>



<h2>Logique de contrôle polyvalente</h2>
	<p>
		Pour simplifier conception du circuit de contrôle, on peut recourir au concept de microcode :
		on utilise une petite mémoire (µMEM) qui contient les opérations à effectuer pour exécuter chaque instruction.
		À chaque nouvelle instruction le microcompteur (µPC) est remis à zéro, puis à chaque étape il est incrémenté.
		En combinant le registre d'instruction et le µPC on génère l'adresse mémoire des opérations qu'il faut effectuer à cette étape de l'instruction.
		Les opérations / les signaux de contrôle sont directement reliés aux composants du processeur.

	</p>
		<img class="third center" src="/img/micromemlogic.svg">


<h2>Le dilemne de l'octet</h2>
	<p>
		La quasi totalité des processeurs modernes fonctionnent sur base du système de l'octet : 8, 16, 32, 64bits.
		La mémoire des ordinateurs modernes est indexées à l'octet près pour des raisons historiques et pratique
		(initialement pour l'encodage des caractères, norme ASCII). Les machines plus primitives utilisaient un nombre
		assez grand de bits puisque le but était plutôt d'avoir le plus de chiffres significatifs pour du calcul scientifique,
		et non à des fins de traitement de texte.

		L'idée n'étant pas de construire un système compatible avec les mémoires actuelles, on choisira le nombre de
		bits avant tout pour coincider avec l'architecture choisie.
	</p>
</article><article class='box'><h1>Programmation machine</h1>

<h2>Présentation</h2>
	<p>
		La logique de contrôle interprète les instructions qui lui sont envoyées, elles sont en binaire comme le reste des données qui circulent dans le processeur.
	</p>

<h2>Langage machine</h2>
	<p>
		La façon dont les instructions sont "encryptées" en binaires est choisie sur plusieurs critères :
		facilité à décoder pour simplifier la logique de contrôle, longueur des instructions et dépend l'architecture en elle-même.
		De manière évidente un processeur qui n'a pas de circuit pour multiplier n'aura pas d'instruction "multiplier".
	</p>

	<p>
		Reprenons la seconde architecture de la partie précédente. On conçoit des opérations de la forme "registre_0 := registre_1 {fonction} registre_2".
		Il y a 8 registres, il faut donc 3 bits pour encoder/identifier un registre. Admettons que l'UAL est capable de 16 fonctions différentes : 4 bits suffisent pour les encoder.
		On peut représenter les instructions avec 16 bits de cette manière :
	</p>


	<img class="three-fourths center" src="/img/testarch2ins.svg">

	<p>
		Avec OP l'opération, DST le registre de destination, SRC les registres sources, FL un bit pour ne pas enregistrer de nouveaux flags et COND pour préciser une condition
		(l'instruction sera annulée si la condition n'est pas remplie : "le flag zéro vaut 1" par exemple).
		Supposons aussi que certaines fonctions de l'UAL prennent directement la valeur SRC2 en entrée au lieu de la valeur du registre SRC2.
		Cela permet de faire des calculs directement avec des valeurs précisées dans l'instruction.
	</p>

<h2>Langage assembleur</h2>
	<p>
		Pour simplifier la programmation il est commode de transcrire les nombres binaires par des codes alphanumériques qui symbolisent l'instruction en question.
		Normalement le terme "assembleur" désigne le programme qui fait la transcription.
	</p>


		<textarea style="resize: none;" class="center" rows="13" cols="80" readonly>
;Fibonacci Binaire

	1100 001 000 001 0 00
	1100 010 000 000 0 00


	0100 011 001 000 0 00
	0000 001 001 010 0 00
	0100 010 011 000 0 00

	1001 111 111 100 0 00

		</textarea>
		<br>
		<textarea style="resize: none;" class="center" rows="13" cols="80" readonly>
;Fibonacci Assembleur

	MOV A 1 	;mettre 0 dans A
	MOV B 0		;mettre 0 dans B

boucle :
	MOV C A   	;mettre A dans C
	ADD A A B 	;mettre A+B dans A
	MOV B C   	;mettre C dans A

	SUB PC PC 4  	;sauter de -4 i.e revenir dans la boucle
		</textarea>


	<p>
		L'assembleur donne le contrôle total sur la machine, cepandent cela peut vite devenir compliqué :
		les processeurs d'aujourd'hui possèdent un grand nombre d'instructions et devoir se référer
		au manuel toutes les 10 secondes n'est pas pratique.
		La notion de variable est assez vague : il faut spécifier l'adresse mémoire plutôt qu'un nom.
		De plus l'assembleur est spécifique à la machine puisque qu'il y a correspondance avec le langage machine.
	</p>


<h2>Langages de haut niveau</h2>
	<p>
		D'autres langages ont été élaborés pour faire abstraction de la machine pour à nouveau rendre la programmation plus efficace, pratique et
		lisible. Ils doivent quand même être convertis en langage machine à un moment ou à un autre : un compilateur
		est un programme qui converti un fichier texte (qui contient du code) en un fichier exécutable par l'ordinateur.
	</p>

	<textarea style="resize: none;" class="center" rows="12" cols="80" readonly>
#Fibonacci Python

a = 1
b = 0

while (True) : #pas de condition d'arrêt
	c = a
	a = a + b
	b = c


	</textarea>

	<p>
		L'exemple de Python est un peu particulier cepandent, en réalité il s'agit d'un programme qui lit les fichiers script (.py)
		et les execute en temps réel : ici on parle plutôt d'interpréteur que de compilateur. Le code n'est pas intégralement
		converti en langage machine avant d'être exécuté. Cela a ses avantages et inconvénients.
	</p>
</article>
    </section>
    

    </section>

  </body>




</html>
