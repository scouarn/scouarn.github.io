<h1>Les nombres entiers<span class="date">21/03/2020</span></h1>

<p>
On entend souvent qu'un ordinateur "est fait de 0 et de 1", en réalité cela veut juste dire
qu'à l'échelle de l'électronique les nombres sont représentés en binaire : on compte avec deux chiffres.
Par exemple le nombre 35 s'écrit '100011' en binaire. Notre processeur ne peut manipuler que 8 bits à la
fois, c'est à dire des entiers entre 0 et 255. En revanche les adresses mémoires sont sur 16 bits ce qui
nous donne des entiers entre 0 et 65535, on dira qu'on a une mémoire de 64kio (2^16).
</p>
<p>
Puisque notre UAL ne peut pas dépasser 255, lorsque l'on fait par exemple l'addition 0b11111111 + 0b1 (255+1) le résultat
ne va pas être 256 mais 0 : la retenue de l'addition a été perdue.
Par analogie en base 10 en se limitant à 3 chiffre, si l'on 999 + 1 en omettant la dernière retenue on trouve (1)000.
On dit qu'il y a "overflow". Cela peut être utilisé à notre avantage pour représenter des nombres négatifs et faire des soustractions,
en effet on remarque que lorsqu'on ajoute 255, cela revient à soustraire 1. On remarque également que le bit
le plus important détermine le signe du nombre. Il faut donc faire attention à ne pas confondre un
entier naturel avec un entier relatif. Il est également possible de représenter des nombres dyadique,
l'équivalent binaire des nombres décimaux mais nous verrons ça plus tard.
</p>
<p>
Comme écrire des nombres en binaire prend beaucoup de place, est parfois peu lisible et que la conversion
en base 10 est difficile, on préfère parfois écrire dans une base qui est une puissance de 2 : la conversion est alors simple.
Par exemple en base 8 (octal) un chiffre correspond à 3 bits car 8 = 2^3.
Comme on a l'habitude de ranger les nombres binaires par paquets de 8 (octets), il est plus simple
d'utiliser la base 16 (hexadécimal) car 1 chiffre équivaut à 4 bits (16 = 2^4), un octet peut alors être
écrit avec simplement deux chiffres héxadécimaux : 255 = 0b11111111 = 0xFF.
La conversion n'est alors plus qu'une question de transcription mais comme Javascript comprend nativement
ces écritures, je n'ai pas eu grand chose à faire pour l'émulateur et l'assembleur. 

</p>
