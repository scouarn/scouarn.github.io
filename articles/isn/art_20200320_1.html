<h1>Les instructions <span class="date">20/03/2020</span></h1>

<p>
Un processeur exécute les instructions qu'on lui donne une par une.
Le langage machine définie la manière dont ces instructions sont encodées en binaire.
J'ai conçu le processeur et le set d'instructions pour que chaque instruction corresponde
à deux octets, c'est à dire 2 paquet de 8 bits. Le premier octet encode l'instruction
et le second un argument qui peut être une adresse mémoire ou un nombre (entre 0 et 255 donc).
</p>

<table style="text-align:center;min-width:600px;width:80%;">
  <tr>
    <td colspan="16">REGISTRE D'INSTRUCTION (OP)</td>
  </tr>
  <tr>
    <td colspan="8">OCTET INSTRUCTION</td>
    <td colspan="8">OCTET ARGUMENT</td>
  </tr>
  <tr>
      <td colspan="2">OPTYPE</td>
      <td colspan="3">OPCODE</td>
      <td>REG</td>
      <td>FLG</td>
      <td>ADR</td>

      <td colspan="8">nombre/adresse</td>
  </tr>
  <tr>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>

      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
  </tr>

</table>

<p>
L'octet d'instruction est séparé en plusieurs parties. J'ai 32 codes d'instructions séparés en 4 catégories (8 par catégorie).
J'ai donc 2 bits qui désignent le type d'instruction et 3 autres pour préciser le code.
Il reste 3 bits qui servent de paramètres :
  <ul>
    <li>REG : si on utilise l'accumulateur A ou B</li>
    <li>FLG : si le registre des flags doit être mis à jour</li>
    <li>ADR : si l'argument est une adresse ou un nombre</li>
  </ul>

</p>


<table style="min-width:600px;width:80%;">

<tr>
  <td style="text-align:center;"colspan="2"><br>TYPE "LOAD"</td>
  <td style="text-align:center;"colspan="2"><br>TYPE "STORE"</td>
</tr>
<tr>
    <td>LDA</td>
    <td>charge l'argument dans l'accumulateur</td>
    <td>STA</td>
    <td>stocke l'accumulateur à l'adresse de l'argument</td>
</tr>
<tr>
    <td>LFL</td>
    <td>charge le registre des flags</td>
    <td>SFL</td>
    <td>stocke le registre des flags</td>
</tr>
<tr>
    <td>POP</td>
    <td>décrémente le registre SP et charge l'adresse pointée</td>
    <td>PSH</td>
    <td>stocke l'acc à l'adresse du SP et l'incrémente</td>
</tr>
<tr>
    <td>PPO</td>
    <td>charge charge l'adresse pointée par le SP moins l'argument</td>
    <td>PSO</td>
    <td>stocke à l'adresse pointée par le SP moins l'argument</td>
</tr>
<tr>
    <td>LSL</td>
    <td>charge l'argument dans le registre des flags</td>
    <td>SSL</td>
    <td>stocke le registre des flags à l'adresse de l'argument</td>
</tr>
<tr>
    <td>LSH</td>
    <td>charge l'argument dans l'octet supérieur du SP</td>
    <td>SSH</td>
    <td>stocke l'octet supérieur du SP</td>
</tr>
<tr>
    <td>LMH</td>
    <td>charge l'argument dans le registre supérieur d'adresse</td>
    <td>SMH</td>
    <td>stocke la valeur du registre supérieur d'adresse</td>
</tr>
<tr>
    <td>LJH</td>
    <td>charge l'argument dans le registre supérieur de saut</td>
    <td>SPH</td>
    <td>stocke l'octet supérieur du compteur ordinal</td>
</tr>
<tr>
  <tr>
    <td colspan="2"></td>
    <td colspan="2"></td>
  </tr>
<tr>
  <td style="text-align:center;" colspan="2"><br>TYPE "UAL"</td>
  <td style="text-align:center;" colspan="2"><br>TYPE "JUMP"</td>
</tr>
<tr>
    <td>ADD</td>
    <td>ajoute l'argument à l'accumulateur</td>
    <td>JMP</td>
    <td>saute à l'adresse de l'argument et du registre de saut</td>
</tr>
<tr>
    <td>SUB</td>
    <td>soustrait l'argument à l'accumulateur</td>
    <td>CAL</td>
    <td>saute en ajoutant l'octet inférieur du compteur au stack</td>
</tr>
<tr>
    <td>AND</td>
    <td>ET logique entre l'argument et l'accumulateur</td>
    <td>JO</td>
    <td>saute si le flag OVERFLOW est mis</td>
</tr>
<tr>
    <td>OR</td>
    <td>OU logique entre l'argument et l'accumulateur</td>
    <td>JNO</td>
    <td>saute si le flag OVERFLOW n'est pas mis</td>
</tr>
<tr>
    <td>XOR</td>
    <td>OU-exclusif entre l'argument et l'accumulateur</td>
    <td>JN</td>
    <td>saute si le flag NEGATIF est mis</td>
</tr>
<tr>
    <td>NOT</td>
    <td>inverse tous les bits de l'accumulateur</td>
    <td>JNN</td>
    <td>saute si le flag NEGATIF n'est pas mis</td>
</tr>
<tr>
    <td>SHL</td>
    <td>décale tous les bits de l'argument vers la gauche</td>
    <td>JZ</td>
    <td>saute si le flag ZERO est mis</td>
</tr>
<tr>
    <td>SHR</td>
    <td>décale tous les bits de l'argument vers la droite</td>
    <td>JNZ</td>
    <td>saute si le flag ZERO n'est pas mis</td>
</tr>
</table>

<p>
On peut alors définir un langage dit "assembleur" qui correspond aux code machine mais qui
utilise les code du tableau ci-dessus. Pour garder les choses simples,
une instruction en assembleur sera aussi en deux parties : un mnémonique (code d'instruction du tableau)
et un argument. Il est ansi relativement retranscrire en langage machine.
</p>
<p>
Les paramètres d'instruction sont en revanche encodés avec des caractères facultatifs :
  <ul>
    <li>"A" ou "B" à la fin de l'instruction pour l'accumulateur utilisé, si rien n'est pas précisé c'est A qui est utlisé</li>
    <li>OPCODE* si le registre des flags doit être mis à jour</li>
    <li>#ARG si l'argument est un nombre immédiat</li>
  </ul>
</p>
<p>
  Exemples :
<ul>
  <li>Si l'on veut par exemple ajouter le nombre 64 à l'accumulateur B et enregistrer les flags l'instruction serait " ADD* #64 B ".</li>
  <li>Si l'on veut soustraire à l'accumulateur A le nombre à l'adresse 0xF0 sans enregistrer les flags l'instruction serait " SUB 0xF0 ".</li>
</ul>
</p>

<p>
On peut noter que l'instruction "ADD 0" ne fait rien, son code machine est le nombre 0.
Comme la mémoire est initialisée à 0, le compteur ordinal va s'incrémenter sans que l'état du
reste du processeur ne change. C'est donc équivalent à une instruction "no operation".
</p>

<p>
Il n'y a pas vraiment d'instruction HALT pour stopper le processeur, la procédure consiste à sauter à l'adresse 0xFFFF.
</p>
