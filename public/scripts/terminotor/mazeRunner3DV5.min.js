const MENU = 0;
const GAME = 1;

let map;
let entities;
let sprites = {};
let player;

let menuButtons = [];
let state;

function preload() {
  //sprites.imp = loadImage("sprites/imp.png");

}

function setup() {
  createCanvas(600,600);
  initMenu();
}

function draw() {

  switch (state) {
    case MENU : displayMenu(); break;
    case GAME : player.update(); break;
  }


}

function keyPressed() {

  switch (state) {
    case GAME : player.onkeyPress(); if (keyCode == 27) initMenu(); break;
  }

}

function mouseClicked() {
  switch (state) {
    case MENU : for(b of menuButtons) if (b.mouseHover()) b.onClick(); break;
    case GAME : player.onClick(); break;
  }
}


function initGame() {
  state = GAME;

  map = new Map(5,5,0.8);

  entities = [];
  for (i = 0; i < 10; i ++) populate();


  if (map.getTile(2,1) == 0)
    player.hA = PI/2;

}

function init2D() {
  player = new Player(moveHover2D,render2D,displayFPS,init2D);
  initGame();
}

function init3D() {
  player = new Player(moveHover3D,render3D,displayFPS,init3D);
  initGame();
}

function initMenu() {
  state = MENU;

  menuButtons.push(new Button(width/2-100,height/2,150,50,"Play 3D",init3D));
  menuButtons.push(new Button(width/2+100,height/2,150,50,"Play 2D",init2D));
}


function Entity(x,y,a,s) {

  this.x = x;
  this.y = y;
  this.a = a;

  this.sprite3D = s;


}

function populate() {

  let x = Math.random()*map.width;
  let y = Math.random()*map.height;

  if (map.getTile(x,y) == 1) entities.push(new Entity(x,y,Math.random()*Math.PI*2,sprites.imp));
  else populate();

}



function displayFPS() {
  fill(255);
  noStroke();
  textSize(16);
  textAlign(LEFT,TOP);
  text(Math.floor(frameRate()*10)/10,10,15);



}



function Map(mazeWidth,mazeHeight,noiseFactor, test = false) {

  if (test)
    this.cells = emptyMap(mazeWidth*2+1,mazeHeight*2+1);
  else
    this.cells = rasterizeMaze(generateMaze(mazeWidth,mazeHeight,noiseFactor));

  this.width = this.cells[0].length;
  this.height = this.cells.length;

  this.cells[this.height-1][this.width-2] = 2;


}

Map.prototype.getTile = function (x,y) {
  return this.cells[floor(y)][floor(x)];
};

Map.prototype.outOfBounds = function (x,y) {
  if (x < 0)
    return true;
  else if (y < 0)
    return true;
  else if (x >= this.width)
    return true;
  else if (y >= this.height)
    return true;
  else
    return false;
};

function emptyMap(w,h) {

  let arr = array2DInit(w,h,0);


  for (x = 1; x < w-1; x++)
    for (y = 1; y < h-1; y++)
      arr[y][x] = 1;

  return arr;
}




//maze generator
///////////////////
let temp_maze;
let temp_visited;
function generateMaze(sizeX,sizeY,noise) {
  temp_maze = array2DInit(sizeX,sizeY,0);
  temp_visited = array2DInit(sizeX,sizeY,0);

  let maze = recursiveBacktracker(0,0);
  maze = addNoise(maze,noise);

  return maze;
}

function recursiveBacktracker(x,y) {

  //Mark the current cell as visited
  temp_visited[y][x] = 1;


  let neighboursVisit = getNeighbours(x,y,temp_visited);

  //While the current cell has any unvisited neighbour cells
  while (neighboursVisit.includes(0)) {

    //Chose one of the unvisited neighbours
    let cell = getIndexRandomFromValue(neighboursVisit,0);


    //Remove the wall between the current cell and the chosen cell
    switch (cell) {

      case 0: temp_maze[y][x] |= 0b1000; temp_maze[y-1][x] |= 0b0010; recursiveBacktracker(x,y-1); break;
      case 1: temp_maze[y][x] |= 0b0100; temp_maze[y][x+1] |= 0b0001; recursiveBacktracker(x+1,y); break;
      case 2: temp_maze[y][x] |= 0b0010; temp_maze[y+1][x] |= 0b1000; recursiveBacktracker(x,y+1); break;
      case 3: temp_maze[y][x] |= 0b0001; temp_maze[y][x-1] |= 0b0100; recursiveBacktracker(x-1,y); break;

    }
    neighboursVisit = getNeighbours(x,y,temp_visited);
  }

  return temp_maze;
}

function addNoise(mz,noise) {
  let sizeX=mz[0].length;
  let sizeY=mz.length;

  for (let x=0; x<sizeX; x++) {
    for (let y = 0; y<sizeY; y++) {

      if ([1,2,4,8].includes(mz[y][x]) && random()<noise) { //dead ends
        let side = floor(random(4));

        switch (side) {
          case 0: if (y<=1){break;}        mz[y][x] |= 0b1000; break;
          case 1: if (x>=sizeX-1){break;}  mz[y][x] |= 0b0100; break;
          case 2: if (y>=sizeY-1){break;}  mz[y][x] |= 0b0010; break;
          case 3: if (x<=1){break;}        mz[y][x] |= 0b0001; break;

        }




      }
    }

  }

  return mz;
}

function getIndexRandomFromValue(arr,val) {

  let i = floor(random(arr.length));
  if (arr[i] == val) {
    return i;
  }
  else {
    return getIndexRandomFromValue(arr,val);
  }
}

function getNeighbours(x,y,arr) {
  let neighbours = [1,1,1,1]; //default true to deal with edges in backtracker function

  if (y>=1)
    neighbours[0] = arr[y-1][x];

  if (x<arr[0].length-1)
    neighbours[1] = arr[y][x+1];

  if (y<arr.length-1)
    neighbours[2] = arr[y+1][x];

  if (x>=1)
    neighbours[3] = arr[y][x-1];

  return neighbours;
}


function rasterizeMaze(mz) {
  let sizeX = mz[0].length;
  let sizeY = mz.length;

  let mp = array2DInit(2*sizeX+1,2*sizeY+1,0);


  for (let x=0; x<sizeX; x++) {
    for (let y=0; y<sizeY; y++) {

      let walls = mz[y][x];
      let mpX = 2*x+1;
      let mpY = 2*y+1

      mp[mpY][mpX] = 1;   //CELL

      if ((walls & 8) != 0)  //HAUT
        mp[mpY-1][mpX] = 1;

      if ((walls & 4) != 0)  //DROITE
        mp[mpY][mpX+1] = 1;

      if ((walls & 2) != 0)  //BAS
        mp[mpY+1][mpX] = 1;

      if ((walls & 1) != 0)  //GAUCHE
        mp[mpY][mpX-1] = 1;


    }
  }

  return mp;
}


function array2D(cols,rows) {

  let arr = new Array(rows);
  for (let i = 0; i<rows; i++)
    arr[i] = new Array(cols);

  return arr;

}

function array2DInit(cols,rows,value) {

  let arr = array2D(cols,rows)

  for (let x = 0; x<cols; x++)
    for (let y = 0; y<rows; y++)
      arr[y][x] = value;

  return arr;

}



function displayMenu() {
  background(0);
  fill(255);

  textAlign(CENTER,CENTER);
  textSize(64);
  text("TERMINOTOR",width/2,height/4);

  for (b of menuButtons) b.show();




}

function Button(x,y,w,h,label,onClick) {
  this.x = x;
  this.y = y;
  this.w = w;
  this.h = h;
  this.label = label;
  this.onClick = onClick;
}

Button.prototype.show = function () {
  noFill();
  stroke(255);

  if (this.mouseHover()) strokeWeight(5);
  else strokeWeight(2);

  rectMode(CENTER);
  rect(this.x,this.y,this.w,this.h);

  fill(255);
  noStroke();
  textAlign(CENTER,CENTER);
  textSize(32);
  text(this.label,this.x,this.y);
};

Button.prototype.mouseHover = function () {
  return (mouseX > this.x-this.w/2 && mouseX < this.x+this.w/2 && mouseY > this.y-this.h/2 && mouseY < this.y+this.h/2)
};


function moveHover3D() {


  let keys = (keyIsDown(90) << 3) | (keyIsDown(81) << 2) | (keyIsDown(83) << 1) | (keyIsDown(68));
  let COSPA = Math.cos(this.hA); let SINPA = Math.sin(this.hA);

  switch (keys) {
    //Z; Q; S; D; Z+Q; Z+D; S+Q; S+D
    case 0b1000: this.vX += COSPA*this.acc; this.vY += SINPA*this.acc; break;
    case 0b0100: this.vX += SINPA*this.acc; this.vY -= COSPA*this.acc; break;
    case 0b0010: this.vX -= COSPA*this.acc; this.vY -= SINPA*this.acc; break;
    case 0b0001: this.vX -= SINPA*this.acc; this.vY += COSPA*this.acc; break;
    case 0b1100: this.vX += this.acc*(COSPA+SINPA)/sqrt(2);  this.vY += this.acc*(SINPA-COSPA)/sqrt(2);  break;
    case 0b1001: this.vX += this.acc*(COSPA-SINPA)/sqrt(2);  this.vY += this.acc*(SINPA+COSPA)/sqrt(2);  break;
    case 0b0110: this.vX += this.acc*(-COSPA+SINPA)/sqrt(2); this.vY += this.acc*(-SINPA-COSPA)/sqrt(2); break;
    case 0b0011: this.vX += this.acc*(-COSPA-SINPA)/sqrt(2); this.vY += this.acc*(-SINPA+COSPA)/sqrt(2); break;
  }

  this.vX *= this.friction, this.vY *= this.friction;

  if (map.getTile(this.pX+this.vX,this.pY) == 0)
    this.vX = 0;
  if (map.getTile(this.pX,this.pY+this.vY) == 0)
    this.vY = 0;

  this.pX += this.vX, this.pY += this.vY;

}

function moveHover2D() {


  let keys = (keyIsDown(90) << 3) | (keyIsDown(81) << 2) | (keyIsDown(83) << 1) | (keyIsDown(68));


  switch (keys) {
    //Z; Q; S; D; Z+Q; Z+D; S+Q; S+D
    case 0b1000: this.vY -= this.acc; break;
    case 0b0100: this.vX -= this.acc; break;
    case 0b0010: this.vY += this.acc; break;
    case 0b0001: this.vX += this.acc; break;
    case 0b1100: this.vY -= this.acc/sqrt(2); this.vX -= this.acc/sqrt(2);  break;
    case 0b1001: this.vY -= this.acc/sqrt(2); this.vX += this.acc/sqrt(2);  break;
    case 0b0110: this.vY += this.acc/sqrt(2); this.vX -= this.acc/sqrt(2); break;
    case 0b0011: this.vY += this.acc/sqrt(2); this.vX += this.acc/sqrt(2); break;
  }

  this.vX *= this.friction, this.vY *= this.friction;

  if (map.getTile(this.pX+this.vX,this.pY) == 0)
    this.vX = 0;
  if (map.getTile(this.pX,this.pY+this.vY) == 0)
    this.vY = 0;

  this.pX += this.vX, this.pY += this.vY;

}


function Player(move,render,radar,reset) {
  this.pX = 1.5; this.pY = 1.5;
  this.vX = 0; this.vY = 0;
  this.acc = 0.007; this.friction = 0.92;
  this.turnRate = 0.06; this.hA = 0; this.vA = 0;

  this.move = move;
  this.render = render;
  this.radar = radar;
  this.onkeyPress = ()=>{};
  this.onClick = requestPointerLock;
  this.reset = reset;
}


Player.prototype.update = function() {
  if (map.getTile(this.pX,this.pY) == 2)
    this.reset();

  this.move();
  this.render();
  this.radar();

};


function render2D() {
  const fov = Math.PI/2;
  const dAnlge = 0.02;

  const tileW = 100;

  let pX_screen = this.pX*tileW;
  let pY_screen = this.pY*tileW;

  this.hA = Math.atan((mouseY-height/2)/(mouseX-width/2));
  if (mouseX-width/2 < 0)
    this.hA += Math.PI;

  background(0);
  push();

  translate(width/2 - pX_screen - (mouseX-width/2)/3, height/2 - pY_screen - (mouseY-height/2)/3);


  stroke(255);
  strokeWeight(5);
  strokeCap(SQUARE);

  let rays = [];
  for (a = this.hA-fov/2; a < this.hA + fov/2; a+= dAnlge) {
    ray = rayCast(this.pX,this.pY,a);
    if (ray != undefined) rays.push(ray);
  }

  //rayons
  for (r of rays)
    line(pX_screen,pY_screen,tileW*r.x,tileW*r.y);

  //points sur les murs/"textures" (pour la sortie)
  strokeWeight(10);
  for (r of rays) {
    if (map.getTile(r.x,r.y) == 2) {
      stroke(0,255,0);
      point(tileW*r.x,tileW*r.y);
    }
  }

  //grille
  stroke(128);
  strokeWeight(1);
  noFill();
  rectMode(CORNER);
  for (x = floor(this.pX)-width/tileW; x < floor(this.pX)+width/tileW; x++)
    for (y = floor(this.pY)-height/tileW; y < floor(this.pY)+height/tileW; y++)
      rect(x*tileW,y*tileW,tileW,tileW);



  //joueur
  noStroke();
  fill(0,255,0);
  ellipse(pX_screen,pY_screen,tileW*0.5,tileW*0.5);
  stroke(0,255,0);
  strokeWeight(3);
  line(pX_screen,pY_screen,pX_screen+tileW*Math.cos(this.hA),pY_screen+tileW*Math.sin(this.hA));

  //entités
  fill(255,0,0);
  for (e of entities) {

    let dx =  e.x - this.pX; let dy =  e.y - this.pY; //VECTEUR DE POSITION RELATIVE

    let angle = Math.atan2(sin(this.hA),cos(this.hA)) - Math.atan2(dy,dx);  //CALCULE LA DIFFERENCE D'ANGLE ENTRE DEUX VECTEURS
    if (angle > Math.PI) angle -= Math.PI*2;  //AJUSTE POUR PAS AVOIR LE CHANGEMENT BRUTAL ENTRE 0 ET 2PI
    else if (angle < -Math.PI) angle += Math.PI*2;  //IDEM POUR 0 ET -2PI

    if (Math.abs(angle) > fov/2) continue;    //STOP SI N'EST PAS DANS LE CHAMP DE VISION


    let dist = sqrt(dx*dx + dy*dy); //DISTANCE AVEC L'OBJET
    let ray = rayCast(this.pX,this.pY,this.hA-angle);

    if (ray.d < dist) continue; //SI UN MUR EST DEVANT L'OBJECT ON STOP

    let ex_screen = e.x*tileW;
    let ey_screen = e.y*tileW;

    noStroke();
    ellipse(ex_screen,ey_screen,tileW*0.5,tileW*0.5);
    stroke(255,0,0);
    line(ex_screen,ey_screen,ex_screen+tileW*Math.cos(e.a),ey_screen+tileW*Math.sin(e.a));
  }




  pop();
}

function render3D() {
  const fov = Math.PI/3;
  const colw = 6;
  const screenDist = (width/2)/tan(fov/2);

  this.hA = (this.hA + Math.atan(movedX/screenDist));
  this.vA = constrain(this.vA-movedY,-height,height);


  let center = height/2 + this.vA;
  noStroke();
  rectMode(CORNER);
  fill(0);
  rect(0,0,width,center);
  fill(20);
  rect(0,center,width,height-center);

  strokeWeight(colw);
  strokeCap(SQUARE);


  let initialAngle = this.hA - fov/2;
  let anglePerCol = fov/width;

  for (x = 0; x < width; x += colw) {
    ray = rayCast(this.pX,this.pY,initialAngle+x*anglePerCol);

    if (ray == undefined) continue;

    let perspectiveDist = ray.d*Math.cos(ray.a-this.hA); //dist > 0 quand FOV<PI car du coup cos>0
    let halfWallHeight = (1/perspectiveDist)*screenDist*0.5;

    let shade = Math.floor(220/(ray.d*2+1));


    let col = color(0);

    switch (map.getTile(ray.x,ray.y)) {
      case 0: col = color(min(shade,200)); break;
      case 2: col = color(0,255,0); break;
    }
    stroke(col);
    line(x,center-halfWallHeight,x,center+halfWallHeight);
  }




  rectMode(CENTER);
  fill(255,0,0);
  stroke(0,0,255);

  let colsPerAngle = width/fov;
  let visibileEntities = [];
  for (e of entities) {

    let dx =  e.x - this.pX; let dy =  e.y - this.pY; //VECTEUR DE POSITION RELATIVE

    let angle = Math.atan2(sin(this.hA),cos(this.hA)) - Math.atan2(dy,dx);  //CALCULE LA DIFFERENCE D'ANGLE ENTRE DEUX VECTEURS
    if (angle > Math.PI) angle -= Math.PI*2;  //AJUSTE POUR PAS AVOIR LE CHANGEMENT BRUTAL ENTRE 0 ET 2PI
    else if (angle < -Math.PI) angle += Math.PI*2;  //IDEM POUR 0 ET -2PI

    if (Math.abs(angle) > fov/2) continue;    //STOP SI N'EST PAS DANS LE CHAMP DE VISION


    let dist = sqrt(dx*dx + dy*dy); //DISTANCE AVEC L'OBJET

    if (dist < 0.2) continue; //CLIP LE SPRITE SI TROP PROCHE

    let ray = rayCast(this.pX,this.pY,this.hA-angle);

    if (ray.d < dist) continue; //SI UN MUR EST DEVANT L'OBJECT ON STOP


    let spriteHeight = screenDist/(dist*cos(angle));   //HAUTEUR EN PIXELS DU SPRITE

    visibileEntities.push({"d":dist,"h":spriteHeight,"x":width/2 - angle*colsPerAngle});

  }

  visibileEntities.sort((a,b)=>{return b.d-a.d}); //trie par distance

  for (e of visibileEntities)
    rect(e.x, center,e.h/2,e.h);



}

function rayCast(pX,pY,rayAngle) {


    let pfX = floor(pX); let pfY = floor(pY);
    let pdX = pX - pfX;  let pdY = pY - pfY;


    let TANA = Math.tan(rayAngle);


    //première intersection
    let hIntX; let hIntY;
    let vIntX; let vIntY;

    //distance à la prochaine intersection
    let hIntDX; let hIntDY;
    let vIntDX; let vIntDY;


    if (Math.sin(rayAngle) > 0) { //BAS
      hIntX = pX + (1-pdY)/TANA;
      hIntY = pfY + 1;

      hIntDY = 1;
      hIntDX = 1/TANA;
    }
    else {             //HAUT
      hIntX = pX - pdY/TANA;
      hIntY = pfY - 0.0001;

      hIntDY = -1;
      hIntDX = -1/TANA;
    }

    if (Math.cos(rayAngle) > 0) { //DROITE
      vIntX = pfX +1;
      vIntY = pY + (1-pdX)*TANA;

      vIntDX = 1;
      vIntDY = TANA;
    }
    else {             //GAUCHE
      vIntX = pfX - 0.0001;
      vIntY = pY - pdX*TANA;

      vIntDX = -1;
      vIntDY = -TANA;
    }


    //trace ray

    //check horizontal intersection :
    let hInt = false;
    while (hInt == false){

      if (map.outOfBounds(hIntX,hIntY))
        break;
      else if (map.getTile(hIntX,hIntY) != 1)
        hInt = true;
      else {
        hIntX += hIntDX;
        hIntY += hIntDY;
      }
    }

    //check vertical intersection :
    let vInt = false;
    while (vInt == false) {

      if (map.outOfBounds(vIntX,vIntY)) {
        break;
      }
      else if (map.getTile(vIntX,vIntY) != 1)
        vInt = true;
      else {
        vIntX += vIntDX;
        vIntY += vIntDY;
      }
    }

    let hDist = (hIntX-pX)*(hIntX-pX) + (hIntY-pY)*(hIntY-pY);
    let vDist = (vIntX-pX)*(vIntX-pX) + (vIntY-pY)*(vIntY-pY);
    let trueDist;

    let finalX;
    let finalY;

    if (hInt && hDist < vDist)
      return {"a":rayAngle,"x":hIntX,"y":hIntY,"d":Math.sqrt(hDist)};

    else if (vInt)
      return {"a":rayAngle,"x":vIntX,"y":vIntY,"d":Math.sqrt(vDist)};

}
